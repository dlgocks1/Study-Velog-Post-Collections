
## 이메일 프로토콜


| 프로토콜     | 풀네임                              | 주요 역할                       | 특징                                                         | 기본 포트                                |
| -------- | -------------------------------- | --------------------------- | ---------------------------------------------------------- | ------------------------------------ |
| **POP3** | Post Office Protocol v3          | 메일 서버 → 클라이언트 다운로드          | - 메일을 로컬로 가져온 뒤 기본적으로 서버에서 삭제<br>- 단말기 여러 대에서 동기화 불편       | 110 (일반), 995 (SSL/TLS)              |
| **IMAP** | Internet Message Access Protocol | 메일 서버 ↔ 클라이언트 동기화           | - 메일을 서버에 남겨두고, 여러 기기에서 동일하게 접근 가능<br>- 폴더/상태(읽음/안읽음)도 동기화 | 143 (일반), 993 (SSL/TLS)              |
| **SMTP** | Simple Mail Transfer Protocol    | 메일 전송 (클라이언트 → 서버, 서버 → 서버) | - 메일 보내는 용도 전용<br>- POP/IMAP과 함께 사용됨<br>- 인증 + 암호화 지원      | 25 (기본), 465 (SMTPS), 587 (STARTTLS) |

책에서는 HTTPS를 활용하여 메일함 접속 서비스를 구현한다. 

## DNS에 대하여

### DNS (Domain Name System)
인터넷에서 도메인 이름 ↔ IP 주소를 매핑해주는 시스템

### MX (Mail Exchange)
메일 전송할 때 "해당 도메인으로 메일을 보내려면 어떤 메일 서버로 가야 하는가?"를 알려주는 정보
SMTP 서버들이 메일을 주고받을 때 MX 레코드를 사용한다.

```
> nslookup -type=mx gmail.com

Server:		-
Address:	-

Non-authoritative answer:
gmail.com	mail exchanger = 20 alt2.gmail-smtp-in.l.google.com.
gmail.com	mail exchanger = 30 alt3.gmail-smtp-in.l.google.com.
gmail.com	mail exchanger = 5 gmail-smtp-in.l.google.com.
gmail.com	mail exchanger = 10 alt1.gmail-smtp-in.l.google.com.
gmail.com	mail exchanger = 40 alt4.gmail-smtp-in.l.google.com.
```

여러 MX 레코드가 설정되어 있다면 **우선순위가 낮은 레코드가 먼저 메일을 수신**하고, 주요 서버 장애 시 높은 우선순위(백업) 서버로 자동 전환

Gmail은 여러 개의 메일 서버를 두고, 우선순위(5, 10, 20 …)에 따라 트래픽을 분산 처리


## 전통적 메일 서버

![](https://velog.velcdn.com/images/cksgodl/post/36107b24-fa7f-4a89-81db-3509dfd73e1d/image.png)

- 메일 전송을 위한 SMTP 포로토콜
- 메일 수신을 위한 IMAP/POP 프로토콜

![](https://velog.velcdn.com/images/cksgodl/post/a1eb22b6-6132-4c1a-b91a-a4410ce4bad8/image.png)

전통적 메일 서버는 데이터를 파일 시스템의 디렉터리에 저장
사용량이 많아지면서 디스크 I/O 병목 및 가용성, 안정성 문제 발생

-> 분산 데이터 저장소 계층으로 진화

## 분산 메일 서버

### 이메일 API

- 모바일 단말 클라이언트를 위한 SMTP/POP/IMAP API
- 송신 측 메일 서버와 수신 측 메일 서버 간의 SMTP 통신
- 대화형 웹 기반 이메일 애플리케이션을 위한 HTTP 기반 RESTful API

```
POST /v1/messages 엔드포인트 : 메시지 전송
GET /v1/folders 엔드포인트 : 이메일 계정의 모든 폴더 반환
GET /v1/folders/{:folder_id}/messages 엔드포인트 : 폴더 아래의 모든 메시지 반환
GET /v1/messages/{:message_id} 엔드포인트 : 특정 메시지의 모든 정보 반환
```

### 분산 메일 서버 아키텍처

![](https://velog.velcdn.com/images/cksgodl/post/d24ff84a-b58d-46fb-a8af-53fff57b01ee/image.png)

- 웹메일 : 사용자가 웹브라우저
- 웹서버 : 위에서 다룬 이메일 API 요청
- 실시간서버 : 새로운 이메일 내역을 클라이언트(웹메일)에 실시간으로 전달
지속성 연결을 맺고 유지해야 하므로 상태 유지(stateful) 서버
   - _굳이?_
- 메타데이터DB : 이메일 제목, 본문, 발신인, 수신인 목록 등의 메타데이터 저장소
- 첨부파일 저장소 : 아마존 S3(Simple Sotrage Service) 같은 객체 저장소 사용
- 분산 캐시 : 레디스 메일 캐시
- 검색 저장소 : ES, 별도 구현

### 이메일 전송 절차

![](https://velog.velcdn.com/images/cksgodl/post/6b021490-3f25-40c3-9fca-b0fecdaa25cb/image.png)

### 이메일 수신 절차

![](https://velog.velcdn.com/images/cksgodl/post/9dc93aa3-fe27-47de-a20e-7ad27a3e1112/image.png)


## 상세 정보

### 데이터베이스
 
- 강력한 데이터 일관성이 보장되어야 한다.
- 디스크 I/O가 최소화되도록 설계되어야 한다.
- 가용성이 높아야 하고 일부 장애를 감내할 수 있어야 한다.
- 증분 백업(incremental backup)이 쉬워야 한다.

책에서는 RDB, SoSQL, S3등을 이야기 하였지만, 대체로 독자적인 전용 메일 스토리지 활용

### 파티션키와 클러스터 키

#### 파티션 키 (Partition Key)

데이터를 어느 노드(서버)에 저장할지 결정하는 키

#### 클러스터 키 (Clustering Key)

파티션 안에서 데이터의 정렬 순서와 고유성을 결정하는 키

> 이메일 시스템에서는 user_id를 파티션 키로 사용하여 특정 사용자 데이터가 항상 같은 샤드에 있도록 보관함. + 보관 타임유닛을 클러스터 키로 활용


### 이메일 검색

이메일 검색을 위해서 전송, 수신, 삭제시마다 색인 갱신 작업을 수행해야 함

#### ES를 활용

![](https://velog.velcdn.com/images/cksgodl/post/a859649c-a097-4a22-8e89-1170ca45eb2e/image.png)

#### 맞춤형 검색 엔진

메일 색인 서버의 주된 병목은 디스크 I/O이다.
따라서 다량의 쓰기 연산을 발생시킬 수 밖에 없으므로, LSM(Log-Structured Merge) 트리 방식을 사용하여 디스크에 저장되는 색인을 구조화 하는 것이 바람직한 전략이다.

![](https://velog.velcdn.com/images/cksgodl/post/ec2b4f87-87d1-4921-80ea-41cbc4bbc2c7/image.png)


> #### LSM 구조란?
> 이름 그대로 로그(append-only) 기반 구조 + 머지(merge) 방식을 결합한 트리 구조
> 목표: 디스크의 랜덤 쓰기(Random Write) 를 순차 쓰기(Sequential Write) 로 바꿔서 I/O 성능 극대화

- WAL에도 활용되는 구조 
- 쓰기는 메모리의 Memtable → 일정 크기 찼을 때 디스크의 SSTable로 flush. 
- 여러 SSTable이 쌓이면 Compaction으로 병합.

사용처 
- Cassandra, HBase 같은 NoSQL DB
- RocksDB, LevelDB 같은 Key-Value Store
- Elasticsearch, Lucene 기반 검색엔진

### 규모 확장

![](https://velog.velcdn.com/images/cksgodl/post/0ac4ae0c-cfd3-49f4-b329-df23d264c5ef/image.png)
