## 호텔 예약시스템에서의 관계형 DB 사용

### 읽기/쓰기 패턴 최적화

호텔 예약 시스템은 객실/호텔 정보 열람 등 읽기 작업이 많고, 실질적인 예약(쓰기)은 상대적으로 적기 때문이다.

### 트랜잭션 및 ACID 제공

예약 정보는 데이터의 일관성, 무결성, 안정적인 모델링, 그리고 트랜잭션 관리(ACID 보장)가 필수적이기 때문이다.

예약정보는 중복, 동시에 처리되는 경우 이중 예약이나 결제 같은 문제가 발생할 수 있는데, RDBMS는 이런 오류를 방지한다.

> **ACID란?**
>
> ACID는 데이터베이스 트랜잭션의 4가지 핵심 속성을 의미하며, 각각의 약어는 다음을 뜻합니다: 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability).
>
- 원자성(Atomicity)
  - 트랜잭션의 모든 작업이 모두 성공하거나 모두 실패하도록 한다.
- 일관성(Consistency)
  - 트랜잭션 전후로 데이터의 무결성과 규칙이 항상 만족되도록 한다.
- 격리성(Isolation)
  - 동시에 실행되는 여러 트랜잭션이 서로 영향을 주지 않도록 한다.
- 지속성(Durability)
  - 트랜잭션이 성공하면 시스템 오류가 발생해도 결과가 영구적으로 남도록 한다.


## 멱등 API를 활용한 이중예약 방지

> **멱등성(Idempotency)이란?**
동일한 작업을 여러 번 수행해도 결과가 같아진다.
>
예를 들어, 사용자가 버튼을 여러 번 눌러도 서버는 최초 요청만 처리하고 그 이후엔 상태 변화가 없다.

### 멱등 API로 동시성 문제를 해결하는 방식 예

- 클라이언트에서 중복 클릭 방지 코드를 추가한다.
   - JS조작으로 오류 가능
- **서버에서 멱등키(유니크 ID)를 요청에 포함시켜, 이미 처리된 키는 다시 처리하지 않는다.**
   - [티켓 서비스 백엔드 시스템에서 중복 요청 이슈를 멱등하게 처리하기](https://upcurvewave.tistory.com/646)
![](https://velog.velcdn.com/images/cksgodl/post/1479316d-5c49-414e-8dba-ba15ef920e0b/image.png)
   - 멱등 키의 경우 Redis와 같은 캐시 시스템이나 데이터베이스를 활용해 멱등키를 일정 시간 동안 저장한다.
   - 최종적으로는 보상 트랜잭션(Eventual Consistency, Compensating Transaction), 이벤트 기반 비동기 처리까지 확장해 분산 시스템의 일관성까지 챙긴다.


## 멱등키를 활용해 DB에서 트랜잭션을 제공하는 방식

DB에서 멱등키를 활용해 트랜잭션을 제공하는 방식은 다음과 같다.

1. 트랜잭션 시작
클라이언트가 멱등키와 함께 작업 요청을 보내면, DB에서 명시적으로 트랜잭션을 시작한다(예: START TRANSACTION 또는 수동 커밋 모드 설정).

2. 멱등키 중복 검사 및 락 획득
멱등키(고유 요청 ID)를 저장하는 별도의 테이블에 해당 키가 이미 존재하는지 검사한다.
만약 키가 이미 있으면 해당 요청은 중복이므로 작업을 재실행하지 않고 결과 반환 또는 에러 처리한다.
없으면 새로 삽입하면서 해당 키에 대한 DB 락을 걸어 다른 트랜잭션이 동시에 동일 키를 만들지 못하도록 한다.

3. 주요 작업 수행
멱등키 검증이 완료되면 트랜잭션 내에서 데이터 변경 작업을 수행한다(예: 티켓 등록, 결제 처리).

4. 커밋 또는 롤백
작업이 성공적으로 모두 완료되면 COMMIT하여 트랜잭션을 종료하고 락을 해제한다. 실패하면 ROLLBACK하여 작업 전 상태로 복구한다.

5. 트랜잭션 격리 및 동시성 제어
DB가 제공하는 트랜잭션 격리 수준과 레코드 락을 활용해 동시에 같은 멱등키가 여러 트랜잭션에서 처리되는 것을 방지하고, 데이터 무결성과 원자성을 보장한다.

6. 결과 반환
커밋 후 클라이언트에 성공 결과를 돌려주고, 멱등키로 같은 요청이 재도착하면 바로 저장된 결과를 반환한다.

**1단계부터 트랜잭션이필요하다. 즉, 해당 방식을 활용하기 위해서는 어떤 형태로는 락(lock)을 활용해야 한다.
**

### 비관적 락 (Pessimistic Lock)

데이터 대상(테이블, 행 등)에 직접 락을 걸어 다른 트랜잭션의 접근을 제한한다.
일반적으로 SELECT ... FOR UPDATE 같은 구문을 사용해 특정 행(row)을 잠그고, 락 해제 전까지 다른 트랜잭션이 해당 데이터에 쓰거나 읽기 못하게 한다.

![](https://velog.velcdn.com/images/cksgodl/post/dce7cc6c-4a54-4a0b-b992-e9e702fa2176/image.png)

> 충돌이 많을 것으로 예상되는 상황 : 쓰기 작업이나 경합이 많을 때 주로 사용한다.
But 단점으로 락 대기로 인한 지연, 데드락 가능성 존재.

### 낙관적 락 (Optimistic Lock)

데이터 필드(주로 버전 번호)를 활용하여 동시성 문제를 완화한다.
데이터 수정 시점에 버전을 확인해 변경 전 버전과 다르면 실패를 반환하고 재시도하게 한다.
락 자체를 걸지 않아 트랜잭션 경합이 적은 환경에서 유리하다.
_비관적 락보다는 빠르게 작동_

![](https://velog.velcdn.com/images/cksgodl/post/446d218e-bb27-4108-8e33-1333d044415b/image.png)

> **충돌이 적을 것으로 예상되는 상황**: 여러 사용자가 동시에 데이터를 수정하는 일이 드물 경우 낙관적 락이 효율적입니다. 충돌이 발생하지 않으면 데이터베이스 락을 잡을 필요 없이 처리할 수 있어 성능이 좋습니다.

### 데이터베이스 제약 조건 (Constraint)

Unique 제약 조건 등으로 중복 데이터 삽입을 방지한다.
제약조건 위반 시 DBMS가 자동으로 에러를 발생시켜 데이터 무결성을 보장한다.
이를 통해 추가 락 없이도 중복 데이터 생성 문제를 방지할 수 있다.

대표적 제약조건: PRIMARY KEY, UNIQUE, FOREIGN KEY, CHECK 제약조건 등.
```SQL
ALTER TABLE submission ADD CONSTRAINT unique_submission UNIQUE (exam_id, member_id);
```


### 분산 락

> **분산 락 (Distributed Lock)이란?**
>
분산 락은 여러 대의 서버(노드)가 같은 자원에 동시에 접근하려 할 때, 한 번에 오직 하나의 서버만 접근하도록 하는 락 메커니즘이다.

**단일 시스템 내 락과 달리 네트워크를 통해 분산된 여러 서버 환경에서 동시성을 제어한다.**

- 주로 Redis, Zookeeper, Consul 같은 외부 저장소를 락 서버로 사용한다.
- TTL(Time To Live)을 설정해 락이 일정 시간 지나면 자동 해제해 죽은 노드가 락을 점유하는 문제를 방지한다.
![](https://velog.velcdn.com/images/cksgodl/post/ccab0d33-6c7d-44e7-89a4-a0525d1cdaa5/image.png)

#### 장점
여러 노드 환경에서 데이터 일관성 및 동시성 문제를 효과적으로 제어한다.
서버 장애 시 TTL로 락을 자동 해제해 데드락 방지 가능하다.

#### 단점
네트워크 지연이나 장애 발생 시 락 획득 실패 가능성.
락 획득/해제 과정이 네트워크 요청이므로 성능 오버헤드 존재.
구현 복잡성과 시간 동기화 문제 발생 가능성.

## 규모확장을 위한 데이터베이스 샤딩

### 캐시 업데이트

조회를 위해 캐시를 활용한다면 캐시 갱신을 위해 CDC 메커니즘을 활용할 수 있다.

> CDC(Change Data Capture)는 데이터베이스의 데이터가 변경된(insert, update, delete) 사항을 실시간 또는 거의 실시간으로 감지해 기록하고 추적하는 기술이다.
![](https://velog.velcdn.com/images/cksgodl/post/f310dabc-77a1-47fb-be84-40407265065c/image.png)

간단히 말해, 데이터베이스 안에서 데이터가 변할 때마다 그 변화를 이벤트 형태로 캡처해서 다른 시스템에 전달하거나 실시간 동기화에 활용할 수 있도록 한다. 이를 통해 데이터의 변경 이력을 순서대로 추적하고, 변경된 데이터만 효율적으로 처리할 수 있다.

#### 사례 

- 실시간 데이터 복제 및 동기화
분산 환경이나 마이크로서비스에서 여러 데이터 저장소 간 실시간 데이터 일관성을 유지하기 위해 사용한다.
  예: 온프레미스 DB와 클라우드 DB 간 무중단 마이그레이션 시 변경 데이터만 동기화하여 다운타임 최소화.

- 이벤트 기반 아키텍처(EDA) 구현
  데이터베이스 변경 이벤트를 캡처해 메시지 큐, Kafka 등으로 전달, 실시간 비즈니스 이벤트 트리거로 활용.

### 데이터 일관성을 위한 방식

모노리스 아키텍쳐가 아니라, 마이크로 서비스 아키텍쳐일 떄는 각 모듈간의 일관성 문제가 발생할 수 있다.

![](https://velog.velcdn.com/images/cksgodl/post/0fa95c31-ce3f-464e-a8bb-6ca695d80e31/image.png)

#### 2단계 커밋

> 2단계 커밋(2-Phase Commit, 2PC)은 분산 시스템에서 여러 노드가 참여하는 트랜잭션을 원자적으로 성공하거나 모두 롤백하여 일관성을 유지하기 위한 대표적인 프로토콜입니다.

![](https://velog.velcdn.com/images/cksgodl/post/ab6943ea-24a7-49c7-a6e8-a44389e54d34/image.png)

여러 노드(참여자)가 독립적으로 트랜잭션을 실행한 후 모두 성공해야 최종 커밋합니다.

- 1) 준비 단계 (Prepare Phase)
트랜잭션을 관리하는 중앙 코디네이터(조정자)가 모든 참여 노드에 트랜잭션 준비 요청을 보냅니다.

각 노드는 로컬에서 트랜잭션 실행 후 성공하면 "준비 완료(Prepared)" 메시지를, 실패하면 "실패(Abort)" 메시지를 코디네이터에게 보냅니다.

- 2) 커밋 단계 (Commit Phase)
모든 노드가 준비 완료를 보고한 경우 코디네이터가 커밋 명령을 내려 각 노드가 트랜잭션을 커밋하고 완료 메시지를 반환합니다.

특징 및 단점
트랜잭션의 원자성(atomicity)을 보장하는 표준적인 분산 트랜잭션 커밋 프로토콜

**느려서 잘 안쓰임**

#### 사가

> 사가(Saga) 프로토콜은 분산 시스템에서 긴 실행 시간을 가진 트랜잭션을 관리하기 위한 패턴이다.

![](https://velog.velcdn.com/images/cksgodl/post/cdef4e14-2811-4a61-a042-887622c9e77d/image.png)

트랜잭션을 여러 로컬 트랜잭션의 연속으로 나눈다.

- 각 로컬 트랜잭션이 성공적으로 커밋되면 다음 단계로 넘어간다.
  - 만약 중간에 실패가 발생하면 이전에 완료된 로컬 트랜잭션들을 **보상 트랜잭션(Compensating Transaction)**이라는 반대 작업을 수행해 원래 상태로 되돌린다.
- 2단계 커밋(2PC)과 달리 중앙 코디네이터가 없거나 최소화되며, 시스템이 블로킹 되지 않는 장점이 있다.
   - 보상 트랜잭션을 설계하는 것이 가장 핵심이며 복잡할 수 있다.


> 보상 트랜잭션(Compensating Transaction)
>
> 보상 트랜잭션은 분산 시스템, 특히 마이크로서비스 아키텍처에서 분산 트랜잭션이나 긴 트랜잭션을 처리할 때 실패 시 이전 상태로 되돌리기 위해 사용하는 역작업 또는 복구 작업이다.




