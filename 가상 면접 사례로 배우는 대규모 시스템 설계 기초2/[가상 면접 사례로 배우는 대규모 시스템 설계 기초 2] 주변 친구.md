## 문제 설계

‘주변 친구(Nearby friends)‘라는 모바일 앱 기능을 지원하는 규모 확장이 용이한 백엔드 시스템을 설계해 보겠다.

- ‘주변 친구’는 5마일 반경 이내 친구로 정의
- 친구 위치 정보는 30초 주기
- 하루 주변 친구 검색 기능 활용할 사용자 1억명으로 가정
- 동시 접속자 사용자 수는 10% 가정
  - 10% * 1억 = 천만명
- 평균적 한 사용자가 4000명의 친구를 갖는다고 가정
- 이 기능은 페이지당 20명의 주변 친구를 표시

## 계략적 설계안

![](https://velog.velcdn.com/images/cksgodl/post/fb608921-76c6-4510-900b-948c67904c9c/image.png)

위와같은 P2P설계로도 가능하지만, 이는 효율적이지 않음(항상 온라인이여야만 함) 따라서 공용백엔드를 활용하는 아래 방안이 일반적임

![](https://velog.velcdn.com/images/cksgodl/post/40020204-71f7-42fb-b4f8-39907d26b984/image.png)

_문제는 큰 규모에 적용하기 쉽지 않다._
활성 상태의 동시 접속 사용자가 천만 명 정도에 위치 정보를 30초마다 갱신하면 초당 334,000번 위치 정보 갱신

- TPS : 10,000,000 트랜잭션 / 30초 = 3,333,333.33333TPS(약 334,000번)
- 평균 사용자가 1명은 400명 친구를 갖고, 그 가운데 10%가 인근 활성화 상태라고 가정하면 1,400만건 위치 정보 갱신 요청
  - 초당 334,000번 * 400명 * 10% = 1,400만

![](https://velog.velcdn.com/images/cksgodl/post/81d462a4-aea2-4a61-9a57-87c636ef01af/image.png)

**레디스 위치 정보 캐시**
활성 상태의 사용자의 가장 최근 위치 정보를 캐시하는데 사용
TTL을 지정하여, 시간이 지나면 위치 정보 캐시 삭제

- TTL은 해당 사용자의 위치 정보가 갱신될 때마다 초기화된다. (최대 메모리 사용량은 일정 한도 아래로 유지)
- 각 사용자의 위치 정보는 서로 독립적인 데이터이므로, 사용자 ID를 기준으로 여러 서버에 샤딩하면 부하 또한 고르게 분배할 수 있다. (샤딩 키로 활용)
- 유저당 100바이트면 수 GB이상의 메모리 서버 한대로 천만 명유저 커버 가능

**레디스 펍/섭 서버**
초경략 메세시 버스로 `Redis Pub/Sub` 사용

- 특정 사용자의 친구각각과 연결된 웹소켓 핸들러는 해당 채널의 구독자로 설정된다.

![](https://velog.velcdn.com/images/cksgodl/post/5995e3a5-479a-4bba-bc0e-27a04b2552c2/image.png)


### 레디스 펍/섭 서버와 Kafka의 차이

_[Ref PUB/SUB, 잘 알고 쓰자!](https://medium.com/frientrip/pub-sub-%EC%9E%98-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-de9dc1b9f739)_


1. Hot Stream과 Cold Stream
   Redis에는 그룹이라는 개념이 존재하지 않고, 각 subscriber가 channel을 구독하고 있다. 이때 중요한 점은, Channel은 이벤트를 저장하지 않는다는 것이다. 만일 Channel에 이벤트가 도착했을 때, 해당 채널의 Subscriber가 존재하지 않는다면, 이벤트는 사라진다.

![](https://velog.velcdn.com/images/cksgodl/post/5c53bc3a-c702-48bf-b0de-d649839924b7/image.png)

2. 오프셋의 부제
   아래와 같은 상황일 경우 구독자가 2명이기에 한 유저에게 쿠폰이 2번 발행됨 
![](https://velog.velcdn.com/images/cksgodl/post/3f09d588-6cad-414e-8878-8b5cc52fb25c/image.png)


| 항목                         | Redis Pub/Sub                            | Apache Kafka                                  |
| -------------------------- | ---------------------------------------- | --------------------------------------------- |
| **메시지 전달 방식**              | **실시간 메시지 브로드캐스트** (Subscriber가 있어야 전달됨) | **디스크 기반 로그 저장 + 전달** (Subscriber 없어도 메시지 보존) |
| **Persistence (내구성)**      | ❌ 기본적으로 메시지 저장 안 함                       | ✅ 메시지 저장 가능 (디스크 기반 로그 저장)                    |
| **내결함성 (Fault Tolerance)** | 낮음 (노드 다운 시 메시지 손실)                      | 높음 (Replication, 저장 보장)                       |
| **Consumer 관리**            | 관리 없음 (그냥 구독자에게 바로 발송)                   | Offset 기반 소비자 관리                              |
| **메시지 순서 보장**              | 보장 안 됨                                   | Partition 내 순서 보장                             |
| **확장성 (Scalability)**      | 낮음 (단일 인스턴스 위주)                          | 높음 (클러스터 기반, 파티셔닝)                            |
| **지연 시간 (Latency)**        | 아주 낮음 (매우 빠름)                            | 낮음 (약간 느리지만 빠름)                               |
| **사용 용도**                  | 간단한 알림, 실시간 채팅 등                         | 로그 처리, 이벤트 소싱, 데이터 파이프라인 등                    |

### 주기적 위치 갱신

![](https://velog.velcdn.com/images/cksgodl/post/1712777c-4024-48eb-afca-5e70d682c285/image.png)

1. 클라이언트 위치 변경 사실을 로드밸런서에 전송
2. 로드밸런서는 그 위치 변경 내역을 웹소캣으로 전송
3. 웹소켓 서버는 해당 이벤트를 위치 이동 데이터베이스에 저장
4. 웹소켓 서버는 캐시에 저장. TTL도 갱신
5. 웹소켓 서버는 레이스 펍/섭 서버에 해당 사용자 채널에 위치 발행. 3~5는 병렬로 수행
6. 레디스 펍/섭 모든 구독자(온라인 친구)에게 브로드캐스트
7. 새 위치를 보낸 사용자와 메세지를 받은 사용자의 사이 거리 새로 계산
8. 7에서 계산한 거리가 검색 반경에 넘지 않으면 각 클라이언트에 정보를 전송하고, 넘으면 전송 안함

![](https://velog.velcdn.com/images/cksgodl/post/c2037a2d-0d71-433d-8304-47f84d63e559/image.png)

#### 왜 웹소켓 서버일까? 다른 방식?

> 서버-클라이언트 간 실시간 데이터 통신을 고려할 때, 어떤 프로토콜이 있을까?

- HTTP (Long Polling):
클라이언트가 서버에 HTTP 요청을 보내고 -> 서버는 새로운 데이터가 생길 때까지 응답을 즉시 보내지 않고 대기한다. -> 데이터가 생기면 응답을 보내고, 클라이언트는 즉시 다시 요청을 보내 연결을 유지한다. -> 이렇게 반복적으로 요청을 재시작하며 실시간성을 구현함.
   - 장점 HTTP 프로토콜을 사용하기 때문에 서버와 클라이언트 간의 통신이 단순하고, 네트워크 방화벽에서 많은 경우 허용된다.
   - 단점 실시간성이 낮고, 서버에 부하가 많이 걸릴 수 있다. 클라이언트가 주기적으로 요청을 보내야 하므로 오버헤드가 발생할 수 있다.

- WebSocket
클라이언트에서 서버로 요청 클라이언트는 WebSocket을 통해 서버에 연결을 요청한다.
서버에서 클라이언트로 데이터 전송 서버와 클라이언트는 양방향 연결을 유지하며, 서버나 클라이언트가 원할 때 데이터를 보낼 수 잇다.
   - 장점 양방향 실시간 통신을 지원하며, 연결을 유지하므로 HTTP Long Polling보다 더 낮은 지연 시간과 더 높은 실시간성을 제공한다.
   - 단점 WebSocket 프로토콜을 지원하는 모든 네트워크 환경에서 사용할 수 없을 수 있고, 추가적인 서버 및 클라이언트 구현이 필요할 수 있다.

- Server-Sent Events (SSE)
클라이언트는 첫 HTTP 요청을 서버에 보내고, 서버가 그 연결을 계속 열어두고 통신한다.
  - 장점 단방향 실시간 통신을 제공하며, 특히 서버에서 클라이언트로의 데이터 푸시가 필요한 경우 유용합니다. HTTP 기반으로 동작하므로 기존 인프라와 호환성이 좋다.
  - 단점 양방향 통신이 필요한 경우에는 적합하지 않으며, 모바일 네이티브 애플리케이션에서 지원이 부족할 수 있다.


| 프로토콜                         | 특징                               | 장점                  | 단점                        | 추천 사용 사례           |
| ---------------------------- | -------------------------------- | ------------------- | ------------------------- | ------------------ |
| **WebSocket**                | 전이중 통신 (Full-duplex), TCP 기반     | 빠르고 실시간 양방향 통신 가능   | HTTP보다 복잡한 연결 관리          | 채팅, 게임, 실시간 알림     |
| **Server-Sent Events (SSE)** | 서버 → 클라이언트 단방향 스트리밍, HTTP 기반     | 간단하고 HTTP 기반이라 친숙함  | 클라이언트 → 서버로는 별도 요청 필요     | 뉴스피드, 실시간 알림       |
| **HTTP Long Polling**        | 클라이언트가 요청하고 서버가 응답 지연            | 오래된 브라우저 지원 가능      | 비효율적, 서버 리소스 많이 씀         | 구형 브라우저 대상 실시간 통신  |
| **RPC (with streaming)**    | HTTP/2 기반의 RPC + 스트리밍 지원         | 성능 좋고 양방향 스트리밍 가능   | 브라우저 호환성 이슈 (Polyfill 필요) | 마이크로서비스 간 실시간 통신   |

### 데이터 모델

#### 위치 정보 캐시

위치 정보 캐시는 **레디스를 활용**한다.

![](https://velog.velcdn.com/images/cksgodl/post/29cb1931-eddc-4b28-8ca5-a900f51be66c/image.png)

> 위치 정보 저장에 DB를 사용하지 않는 이유
> 
> 사용자 위치는 하나만 보관하기에 충분한데, 레디스는 읽기 및 쓰기 연산 속도가 엄청나게 빠르므로 해당 목적에 적합하다.
> 주변 친구 기능이 활용하는 위치 정보에 대해서는 영속성을 보장할 필요가 없다. (일회성) + TTL 존재


#### 위치 이동 이력 데이터베이스

```
[user_id, latitude, longitude, timestamp]
```

_이는 엄청난 쓰기 연산이 필요하기에 샤딩이 가능한 어떤 db든지 가능하다._

그 중 막대한 쓰기 연산 부하를 감당할 수 있고, 수평적 규모 확장이 가능해야한다. 이러한 요구사항에서 **카산드라**를 사용할 수 있다.

_카산드라는 분산형 NoSQL 데이터베이스이다._

> 카산드라 Eventually Consistency (최종 일관성)
>
>데이터베이스 시스템에서 모든 복제본이 언젠가는 일관된 상태에 도달할 것임을 보장하는 일관성 모델이다. 카산드라에서 이는 다음과 같은 특성을 가진다.

- 동기 복제
- 분산 환경에서의 적용
- 읽기 작업의 일관성 보장
   - 읽기 팬텀, 쓰기 팬텀 등 방지 + 최근에 쓰여진 데이터가 아니더라도 이전에 쓰인 데이터는 정확하게 읽을 수 있다. **(최종 일관성)**
- 튜너블한 일관성 수준
   - 카산드라는 개발자가 일관성 수준을 조절할 수 있는 옵션을 제공한다. 일관성 수준을 "ONE" (한 노드에만 쓰기를 완료하면 성공)에서부터 "QUORUM" (다수결 일관성, 노드의 과반수 이상에 쓰기가 완료되어야 함) 등 다양하게 설정할 수 있다.

## 상세 설계

### 레디스 펍/섭 서버가 얼마나 필요할지?

**메모리 사용량**
- 필요한 채널의 수: 1억 개(10억 사용자의 10%)
- 모든 채널을 저장하는 데 필요한 메모리: 200GB(1억 * 20바이트 * 100명의 친구 / 10^9)

한 사용자의 활성화 상태 친구 가운데 100명이 주변 친구 기능을 사용한다고 가정한다.
구독자 한 명을 추적하기 위해 내부 해시 테이블과 연결 리스트에 20바이트 상당의 포인터들을 저장해야 한다고 한다.
_100GB 메모리를 설치할 수 있는 최신 서버를 사용할 경우, 모든 채널을 보관하는 데 레디스 펍/섭 서버 2대면 된다._

**CPU 사용량**

* 전송 위치 정보 업데이트 양: 초당 1400만 건
* 필요한 레디스 서버의 수: 1400만 / 100,000 = 140대 (서버 한 대로 감당 가능한 구독자의 수는 100,000이라고 가정)
레디스 펍/섭 서버의 병목은 CPU 사용량이다.

본 설계안이 풀어야 하는 문제의 규모를 감당하려면 분산 레디스 펍/섭 클러스터가 필요하다.

**분산 레디스 펍/섭 서버 클러스터**

서비스 탐색 컴포넌트로 사용 가능한 소프트웨어 중, etcd, **주키퍼** 등이 가장 널리 사용된다.
클라이언트로 하여금 값에 명시된 레디스 펍/섭 서버에서 발생한 변경 내역을 구독할 수 있도록 한다.

이런 클러스터 분산에는 아래와 같은 안정 해시 알고리즘이 활용된다.

![](https://velog.velcdn.com/images/cksgodl/post/522bc71b-1daf-4220-8190-f2a9d330407e/image.png)

#### 안정 해시란?

> 안전 해시 또는 **Consistent Hashing(일명 링 해시, 해시 링)**는 주로 분산 시스템에서 데이터 분산과 서버 확장/축소 시 데이터 재분배 문제를 효율적으로 해결하기 위해 사용되는 해싱 기법

동작방식을 간단히 설명하자면

1. 해시 공간을 링(원형)으로 표현
2. 서버(노드)와 데이터의 해시값 할당
3. 서버 추가/제거 시 동작
   - 서버 추가: 새로운 서버가 링에 추가되면, 해당 서버가 담당하는 구간의 데이터 일부만 새 서버로 이동
   - 서버 제거: 서버가 제거되면, 그 서버가 담당하던 구간의 데이터만 인접한 서버로 이동
전체 데이터 중 일부만 이동하므로, 시스템 확장/축소 시 효율적
4. 부하 분산 및 **가상 노드**
   - 실제 서버 수가 적을 때 데이터가 한쪽에 몰리는 현상을 방지하기 위해, 하나의 서버를 여러 개의 가상 노드로 만들어 링에 여러 번 배치할 수 있다.

![](https://velog.velcdn.com/images/cksgodl/post/afcd40d0-656e-4444-a502-bd0cd9174865/image.png)

주키퍼를 활용해 활성 상태의 모든 레디스 펍/섭 서버로 구성된 해시 링을 보관한다.
메시지를 발행할 채널이나 구독할 채널을 정해야 할 때 이 해시 링을 참조한다.
_Ex. 채널2는 레디스 펍/섭 서버 1번에서 관리되고 있다_

#### [레디스 클러스터의 샤딩키](https://cla9.tistory.com/102)

레디스 클러스터는 전체 키 공간을 0~16,383(총 16,384개)의 해시 슬롯으로 나눈다.

![](https://velog.velcdn.com/images/cksgodl/post/b6098b75-6a4d-409c-ab02-ff5ecf1245c9/image.png)

각 키에 대해 CRC16 해시 함수를 적용한 뒤, 16,384로 나눈 나머지 값이 해당 키의 해시 슬롯 번호가 된다. 
이 때 키 값 자체가 샤딩키 역할을 하며, 별도의 필드를 지정하지 않는다.

### 친구가 많은 사용자

친구 관계는 양방향이며, 팔로어 모델처럼 단방향의 관계는 배제하기 떄문에 유명 인사 시스템은 존재할 수 없다.
펍/섭 구독 관계는 클러스터 내의 많은 웹소켓 서버에 분산되어 있다.
=> 부하는 각 웹소켓 서버가 나누어 처리하므로 핫스팟 문제는 발생하지 않는다.


## 마무리

이번 장에서는 사용자의 위치 정보 변경 내역을 그 친구에게 효율적으로 전달하는 시스템을 설계했다.

- 웹소켓: 클라이언트/서버 사이의 실시간 통신을 지원
- 레디스: 위치 데이터의 빠른 읽기/쓰기 지원
- 레디스 펍/섭: 한 사용자의 위치 정보 변경 내역을 모든 온라인 친구에게 전달하는 라우팅 계층

아래 구성요소들의 규모 확장을 알아보았다.

- RESTful API 서버
- 웹소켓 서버
- 데이터 계층
- 레디스 펍/섭 서버 클러스터
