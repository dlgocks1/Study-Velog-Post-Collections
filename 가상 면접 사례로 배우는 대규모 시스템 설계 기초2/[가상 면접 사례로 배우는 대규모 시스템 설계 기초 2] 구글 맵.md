## 개념 이해

### 측위 시스템

![](https://velog.velcdn.com/images/cksgodl/post/db1ef68a-1a96-4d37-b44a-55d73156b5ba/image.png)

> 위도와 경도
>
> 측위 시스템은 구 표면 상의 위치를 표현하는 체계를 말한다.
위경도 기반 측위 시스템의 경우, 최상단에는 북극이 있고, 최하단에는 남극이 있다.
위도(Latitude)는 주어진 위치가 얼마나 북쪽/남쪽인지를 나타낸다.
경도(Longitude)는 얼마나 동쪽/서쪽인지를 나타낸다.

### 지오 코딩

주소 → 좌표 변환
- 📍 사람이 읽는 주소 → 위도(latitude), 경도(longitude)

```
"서울특별시 강남구 테헤란로 123"
→ (37.5000, 127.0350)
```

### 지오 해싱

좌표 → 짧은 문자열로 변환
- 📌 위도, 경도 → 압축된 문자열 코드

```
(37.5000, 127.0350) → "wydmuwq7"
```
![](https://velog.velcdn.com/images/cksgodl/post/a351d0be-b7ed-4acc-8ea5-2ee2533f2935/image.png)

클라이언트는 현재 보려는 지도 확대 수준에 근거하여 어떤 크기의 타일을 가져올지 고른다.

### 경로 안내 알고리즘을 위한 도로 데이터 처리

- 그래프로 표현한 지도
![](https://velog.velcdn.com/images/cksgodl/post/e450a14f-a5c8-4686-be9b-2340d6422e5b/image.png)

> __모든 경로 탐색 알고리즘은 교차로를 노드(node)로, 도로는 노드를 잇는 선(edge)으로 표현하는 그래프 자료 구조를 가정한다.__

길찾기 알고리즘의 성능은 그래프의 크기에 민감하다. 따라서 전세계의 도로망을 안내 타일 별로 분할하여 활용한다.
이를 통해 필요한 메모리 요구량을 낮출 수 있고, 한번에 처리해야 하는 경로의 양이 줄어들며, 필요한만큼만 불러오면 되기 때문에 탐색 성능도 좋아진다.

#### 길찾기 알고리즘

- 다익스트라 알고리즘 (Dijkstra)
  -  🚀 가중치가 있는 그래프에서 최단 거리를 찾는 대표 알고리즘
  - **우선순위 큐(PriorityQueue)**와 함께 쓰면 매우 효율적
  - 시간복잡도 O(E log V)	

![](https://velog.velcdn.com/images/cksgodl/post/488e89f8-6ac5-49b6-bafd-83540901d162/image.png)

```
1. 시작 노드의 거리는 0, 나머지는 무한대로 초기화
2. 가장 거리가 짧은 노드 선택
3. 선택한 노드를 통해 인접 노드까지의 거리 계산
4. 더 짧은 거리 발견 시 갱신
5. 모든 노드를 방문할 때까지 반복
```

- 벨만-포드 알고리즘 (Bellman-Ford)
   - 단일 시작점 → 모든 노드 최단 거리
   - 음수 간선✅, 음수 사이클 감지✅
   - 시간복잡도: O(V × E)

![](https://velog.velcdn.com/images/cksgodl/post/4918f3aa-742a-4cff-aa6e-c89c10da4d8b/image.png)

```
시작 노드는 0, 나머지는 ∞로 초기화
V - 1번 반복하면서 모든 간선을 확인하고 거리 갱신
(추가 체크) V번째에도 갱신된다면? → 음수 사이클 존재
```

- 플로이드-워셜 알고리즘 (Floyd-Warshall)
   - 모든 노드 → 모든 노드 최단 거리
   - 2차원 배열 dist[i][j] 사용
   - 음수 간선✅
   - 시간복잡도: O(N³)

![](https://velog.velcdn.com/images/cksgodl/post/ea402b61-0388-45e3-a9b9-d87f78d32a1e/image.png)

```
초기화: dist[i][j] = 가중치 (없으면 ∞, 자기 자신은 0)
모든 노드 k 및 모든 쌍 (i, j)에 대해:
if dist[i][j] > dist[i][k] + dist[k][j]:
    dist[i][j] = dist[i][k] + dist[k][j]
k를 거쳐가는 경로가 더 짧으면 갱신하는 방식
````


### 계층적 경로 안내 타일

![](https://velog.velcdn.com/images/cksgodl/post/e05927e5-5d64-4945-b951-3a3823415fe0/image.png)

구체성 정도를 **상, 중, 하**로 구분하여 3가지 종류의 경로 안내 타일을 준비한다.

> 각 크기에 따라 구체성을 다르게하여 각 영역을 커버한다. 각 타일에는 도시와 주를 연결하는 주요 고속 도로 데이터를 둔다.

## 계략적 설계

![](https://velog.velcdn.com/images/cksgodl/post/ca08801d-d0cd-4081-bf49-9e4540b260f1/image.png)

### 위치 서비스

![](https://velog.velcdn.com/images/cksgodl/post/c8bd1b93-0016-46ea-8602-ed20d1b92e1a/image.png)

- 클라이언트가 t초마다 자기 위치를 전송한다. (네이버 15초)
   - 클라이언트가 보내는 위치 정보가 거의 실시간 정보에 가까우므로 ETA(예상 도착 시간)를 좀 더 정확하게 산출할 수 있고, 교통 상황에 따라 다른 경로를 안내할 수도 있다.
   - 해당 위치정보를활용해 도로의 복잡도를 계산할 수도 있다.

![](https://velog.velcdn.com/images/cksgodl/post/cbfe1033-fca6-4901-ab3a-47a35cb49c45/image.png)

> 위치 이력을 클라이언트에 버퍼링해 두었다가 일괄 요청하면 전송 빈도를 줄일 수 있다.

아주 높은 쓰기 요청 빈도에 최적화되어 있고 규모 확장이 용이한 카산드라 같은 데이터베이스가 필요하다.
카프카 같은 스트림 엔진을 활용하여 위치 데이터를 로깅해야 할 수도 있다.

- 통신 프로토콜은 HTTP를 keep-alive 옵션과 함께 사용하면 효율을 높일 수 있을 것이다.
> Keep-Alive란?
>
> HTTP 통신을 끊지 않고 계속 유지해서
여러 요청을 하나의 TCP 연결로 처리하는 방식

이외 `WebSocket`, `SSE`, `Long Polling`, `gRPC`등 활용 가능하다.

### 지도 표시

확대 수준별로 한 벌로 타일을 저장하려면 수백 PB가 필요하다. 따라서 확대 수준에 따라 필요한 타일만 서버에서 가져와야 한다.

그렇다면 클라이언트는 언제 지도 타일을 서버에서 가져오는가? 

- 사용자가 지도를 확대 또는 이동시키며 주변을 탐색한다.
- 경로 안내가 진행되는 동안 사용자의 위치가 현재 지도 타일을 벗어나 인접한 타일로 이동한다.

다량의 지도 타일 데이터를 서버에서 효과적으로 가져오는 방법은 다음과 같다.

- 클라이언트의 위치, 현재 클라이언트가 보는 지도의 확대 수준에 근거하여 필요한 지도 타일을 즉석에서 만든다.
  - 심각한 부하가 걸릴 수 있다.
  - 캐시를 활용하기 어렵다.

- 확대 수준별로 미리 만들어 둔 지도 타일을 클라이언트에 전달하기만 한다.
  - 규모 확장이 용이하고, 성능 측면에서도 유리하다.
  - 지도 타일은 정적이므로 **캐시**를 통해 서비스하기 적합하다.

![](https://velog.velcdn.com/images/cksgodl/post/b72faf80-fb98-4169-9f8e-c96b2f13f587/image.png)

## 상세 설계

### 경로 안내 타일

객체 저장소(ex. S3)에 파일을 보관하고 그 파일을 이용할 경로 안내 서비스에서 적극적으로 캐싱한다. + CDN을 활용한다.

```
Client → CDN → (캐시 없음) 원 서버에서 이미지 가져옴 → 캐싱
Client → CDN → (캐시 있음) 즉시 응답
```

- HTTP 캐시 헤더 세팅
```http
Cache-Control: public, max-age=31536000, immutable
// public → 중간 CDN/브라우저 모두 캐싱 가능
// max-age=31536000 → 1년 캐싱
// immutable → 변경 X
```

#### AWS CloudFront + S3

1. 이미지 S3에 업로드
예: https://s3.amazonaws.com/your-bucket/images/cat.jpg
2. CloudFront 배포 연결
   - TTL 설정: 기본 1년 (max-age=31536000)
   - 쿼리 스트링에 따라 캐시 분리 여부 설정
   - 오리진 헤더 무시하고, 캐시 제어 직접 가능

3. 응답 헤더 설정
```
Cache-Control: public, max-age=31536000, immutable
```
4. 이미지 변경되면?
   → 파일명에 v=1, cat_v2.jpg 등으로 버전 갱신해서 배포


### 사용자 위치 데이터

도로 데이터 및 경로 안내 타일을 갱신하거나, 실시간 교통 상황 데이터나 교통 상황 이력 데이터베이스를 구축하는 데 활용된다.

사용자 위치 데이터를 저장하려면 엄청난 양의 쓰기 연산을 잘 처리할 수 있으면서 수평적 규모 확장이 가능한 데이터베이스가 필요하다.

**카산드라**는 해당 기준을 잘 만족시킬 수 있다.

```
# 사용자 위치 테이블
user_id	timestamp	user_mode	driving_mode	location
101	1635740977	active	driving	(20.0, 30.5)
```

### 지오코딩 데이터베이스

주소를 위도/경도 쌍으로 변환하는 정보를 보관한다.
빠른 읽기 연산을 제공하는 키-값 저장소가 적당하다. (ex. 레디스)

### 미리 만들어 둔 지도 이미지

계산 자원이 많이 사용되고, 같은 이미지를 중복 요청하는 경우가 많다.
이미지는 한 번만 계산하고 그 결과는 캐시해 두는 전략을 쓰는 것이 좋다.
이미지는 지도 표시에 사용하는 확대 수준별로 미리 만들어 두고 CDN을 통해 전송한다.

## 서비스

### 위치 서비스

![](https://velog.velcdn.com/images/cksgodl/post/61a120e5-7b08-42c8-8eb8-e6a26ef76519/image.png)

- 사용자 위치 데이터베이스 
  - 사용자 위치 데이터 저장에는 키-값 저장소를 활용한다. (레디스)

초당 백만 건의 위치 정보 업데이트가 발생하므로 쓰기 연산 지원에 탁월한 데이터베이스가 필요하다.

- NoSQL 키-값 데이터베이스
- 열-중심 데이터베이스
- 데이터 일관성보다는 가용성이 더 중요하다. (가용성과 분할 내성을 만족시키는 데 집중)

**카산드라**가 가장 적합하다.

### 사용자 위치 데이터는 어떻게 이용되는가

사용자 위치는 쓰임새가 다양한 중요 데이터다.

- 새로 개설되었거나 폐쇄된 도로를 감지할 수 있다.
- 지도 데이터의 정확성을 점차 개선하는 입력으로도 활용될 수 있다.
- 실시간 교통 현황을 파악하는 입력이 될 수도 있다.
- 사용자 위치를 카프카와 같은 메시지 큐에 추가적으로 로깅한다.

![](https://velog.velcdn.com/images/cksgodl/post/8e5dfa1b-556f-4a83-93cb-06227f6d4f44/image.png)

### 지도 표시

#### 지도 타일 사전 계산

확대 수준 0은 세계 전부를 256*256픽셀짜리 타일 하나로 표현한다.

확대 수준을 1단계 올릴 때마다 해당 수준을 위한 전체 타일 수는 동서 방향으로 2배, 남북 방향으로 2배 늘어난다.

- 확대 수준 1: 필요한 타일 2*2장, 해당도 512*512 픽셀
- 확대 수준 2: 필요한 타일 4*4장, 해상도 1024*1024 픽셀

> 클라이언트는 해당 정보를 제공하기 위한 타일을 다운 받는 데 많은 네트워크 대역폭을 소진하지 않고도 클라이언트에 설정된 확대 수준에 최적인 크기의 지도를 표시할 수 있다.

#### 최적화: 벡터 사용

이미지 대신 경로와 다각형 등의 벡터 정보를 보낸다.
클라이언트는 수신된 경로와 다각형 정보를 통해 지도를 그려낸다.
이미지에 비해 월등한 압축률을 가지므로, 네트워크 대역폭을 많이 아낄 수 있다.

벡터화 된 이미지를 사용하면 클라이언트는 각 요소 크기를 적절하게 조정할 수 있어 훨씬 매끄러운 확대 경험을 제공할 수 있다.

_그러나 사용자의 기기에 따른 부하가 발생할 수 있다._


### 경로 안내 서비스

![](https://velog.velcdn.com/images/cksgodl/post/868bc8dd-5fc1-437b-befa-3dfa15a55cd8/image.png)

#### 지오코딩 서비스

> 주소를 위도/경도 쌍으로 바꿔주는 서비스

경로 안내 서비스는 출발지와 목적지 주소를 위도/경도 쌍으로 변환한 뒤 추후 다른 서비스 호출에 이용한다. 

#### 경로 계획 서비스

- 최단 경로 서비스

출발지와 목적지 위도/경도를 입력으로 받아 k개 최단 경로를 반환한다. (교통, 도로 상황 고려 X)
객체 저장소에 저장된 경로 안내 타일에 대해 A* 경로 탐색 알고리즘의 한 형태를 실행한다.

> A*(A-Star) 알고리즘이란?
**최단 경로를 찾을 때, 단순히 지금까지 온 거리(g)**뿐만 아니라
**목표까지 예상 거리(h)**도 같이 고려해서
가장 유망한 경로를 먼저 탐색하는 알고리즘
>
> [A* 알고리즘에 대해 알아보자](https://velog.io/@1ncursio/%EC%97%90%EC%9D%B4%EC%8A%A4%ED%83%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90)

- 각 노드에 대해 `f(n) = g(n) + h(n)` 값을 계산
  - g(n): 출발 노드에서 현재 노드(n)까지의 실제 비용 (이동 거리 등)
  - h(n): 현재 노드(n)에서 목표 노드까지의 추정 비용 (휴리스틱 비용)
  - f(n): 두 비용을 합한 값으로, 현재 노드를 거쳐 목표 노드까지 가는 예상 

![](https://velog.velcdn.com/images/cksgodl/post/a15cb8fa-b8a4-4915-adbe-8c71ff2e9fda/image.png)

다익스트라 알고리즘보다 효율적으로 미로를 탐색할 수 있다.

#### 예상 도착 시간 서비스

AI를 활용해 현재 교통 상황 및 과거 이력에 근거하여 예상 도착 시간을 계산한다. N분뒤의 도로 상황또한 예측해야 한다.

#### 순위 결정 서비스

경로 계획 서비스는 ETA(예상 도착시간) 예상치를 구하고 나면 순위 결정 서비스에 관련 정보를 모두 전달하여 사용자가 정의한 필터링 조건을 적용한다.

필터링이 끝나고 남은 경로를 소요 시간 순으로 정렬하여 최단 시간 경로 k개를 구한 다음 경로 안내 서비스에 결과를 반환한다.

#### 중요 정보 갱신 서비스들

카프카 위치 데이터 스트림을 구독하고 있다가 중요 데이터를 비동기적으로 업데이트하여 그 상태를 항상 최신으로 유지하는 역할을 담당한다.

경로 안내 타일 처리 서비스는 도로 데이터에 새로 발견된 도로, 폐쇄되었음이 확인된 도로 정보를 반영하여 경로 안내 타일을 지속적으로 갱신한다.

실시간 교통 상황 서비스는 활성화 상태 사용자가 보내는 위치 데이터 스트림에서 교통 상황 정보를 추출한다.

#### 적응형 ETA와 경로 변경

현 설계안은 적응형 ETA와 경로 변경을 허용하지 않는다.

이를 해결하기 위해 서버는 현재 경로 안내를 받고 있는 모든 사용자를 추적하면서 교통 상황이 달라질 때마다 각 사용자의 ETA를 변경해주어야 한다.

다음 중요한 질문이 있다.
- 현재 경로 안내를 받고 있는 사용자는 어떻게 추적하나?
- 수백만 경로 가운데 교통 상황 변화에 영향을 받는 경로와 사용자를 효율적으로 가려낼 방법은 무엇인가?

![](https://velog.velcdn.com/images/cksgodl/post/eb88ab2f-62dd-42a9-87fe-68ea547b34c3/image.png)

1. r_2에서 교통사고가 발생했다고 가정하자.
2. 레코드를 전수 조사해서 어떤 사용자가 해당 타일을 가지고 있는지 알아내야 한다.
3. 테이블에 보관된 레코드 수가 n이고 안내되는 경로의 평균 길이가 m이라면 교통 상황 변화에 영향 받는 모든 사용자 검색의 시간 복잡도는 O(n*m)이 된다.

![](https://velog.velcdn.com/images/cksgodl/post/444580af-2cd0-4ff7-a86e-0db81826af80/image.png)

🔼 재귀적인 경로 타일 수집

- 경로 안내를 받는 사용자 각각의 현재 경로 안내 타일, 그 타일을 포함하는 상위 타일, 그 상위 타일의 상위 타일을 출발지와 목적지가 모두 포함된 타일을 찾을 때까지 재귀적으로 더하여 보관하는 것이다.
- 어떤 타일의 교통 상황이 변했을 때 경로 안내 ETA가 달라지는 사용자는, 해당 사용자의 데이터베이스 레코드 마지막 타일에 그 타일이 속하는 사용자다.
- 검색 시간 복잡도가 O(n)으로 줄어든다.
- 교통 상황이 개선되었을 때 해야 하는 일까지 해결해 주지 않는다.

### 전송 프로토콜

모바일 푸시 알림은 보낼 수 있는 메시지 크기가 매우 제한적이므로 사용하지 않는 게 바람직하다.

웹소켓은 서버에 주는 부담이 크지 않아서 일반적으로 롱 폴링보다 좋은 방안으로 본다. (+ 양방향 통신 지원)

![](https://velog.velcdn.com/images/cksgodl/post/8f85720e-0db8-42b1-b10c-124cc2d5e0b6/image.png)
