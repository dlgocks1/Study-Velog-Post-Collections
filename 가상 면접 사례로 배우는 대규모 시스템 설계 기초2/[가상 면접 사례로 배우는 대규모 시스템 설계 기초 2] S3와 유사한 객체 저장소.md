아마존 S3(Simple Storage Service)와 유사한 객체 저장소 서비스 설계하기

## 스토리지 시스템

> 데이터 접근 방식과 추상화 레벨에 따라 3가지로 나뉜다. 각각 사용 목적과 성능 특성이 완전히 다르다.

### 블록 저장소

- 데이터를 고정 크기 블록(보통 512B~64KB)으로 나눠서 저장
- 각 블록에 고유 주소(LBA: Logical Block Address) 부여
- 파일 시스템 없이 직접 블록에 접근
- 가장 낮은 레벨의 스토리지

```
디스크/SSD
├─ Block 0 (4KB)
├─ Block 1 (4KB)
├─ Block 2 (4KB)
├─ Block 3 (4KB)
└─ Block 4 (4KB)

애플리케이션 → 파일 시스템 → 블록 저장소 → 물리 디스크
```

AWS EBS (Elastic Block Store)가 해당 구현체의 예시이다.

```python
import boto3

ec2 = boto3.client('ec2')

# EBS 볼륨 생성
volume = ec2.create_volume(
    Size=100,  # 100GB
    VolumeType='gp3',  # SSD
    AvailabilityZone='us-east-1a'
)

# EC2 인스턴스에 연결
ec2.attach_volume(
    VolumeId=volume['VolumeId'],
    InstanceId='i-1234567890abcdef0',
    Device='/dev/sdf'
)
```

### 파일 저장소 (File Storage)

- 데이터를 파일과 폴더 계층 구조로 저장
- 파일 경로로 접근 (예: /home/user/document.txt)
- 네트워크 공유 가능 (NFS, SMB/CIFS)
- 중간 레벨 추상화

```
파일 시스템
├─ /home
│  └─ user
│     ├─ document.txt
│     └─ photo.jpg
├─ /var
│  └─ log
│     └─ app.log
└─ /etc
   └─ config.yaml

애플리케이션 → 파일 시스템 → 블록 저장소
```

AWS EFS에 예시

```python
# AWS EFS (Elastic File System)
import boto3

efs = boto3.client('efs')

# EFS 파일 시스템 생성
file_system = efs.create_file_system(
    PerformanceMode='generalPurpose',
    Encrypted=True
)
```

### 객체 저장소 (Object Storage)

- 데이터를 **객체**(Object)로 저장
- 각 객체는 **고유 키**(Key)로 접근
- **계층 구조 없음** (플랫한 네임스페이스)
- **가장 높은 레벨** 추상화
- **HTTP API**로 접근

```
버킷 (Bucket)
├─ users/profile/123.jpg (객체)
├─ documents/report.pdf (객체)
├─ logs/2024/10/app.log (객체)
└─ images/banner.png (객체)
```

> 주의: users/profile/은 실제 폴더가 아니다.
→ 단지 키의 일부 (프리픽스)

실제 물리적 저장은 아래와 같은 예시
```
					클라이언트
                       ↓
                 [Load Balancer]
                       ↓
        ┌──────────────┼──────────────┐
        ↓              ↓              ↓
   [API Server]   [API Server]   [API Server]
        ↓              ↓              ↓
   		[Metadata DB] (키 → 물리 위치 매핑)
        ↓
   [Storage Node 1]  [Storage Node 2]  [Storage Node 3]
        ↓                  ↓                  ↓
   물리 디스크들       물리 디스크들       물리 디스크들
```




아마존 S3가 예시, Spring S3Client 또한 제공

### 일반적인 웹 애플리케이션 아키텍처

1. OS/앱/데이터베이스 → 블록 저장소 (EBS)
EC2: /dev/xvda (루트 볼륨, 100GB gp3)
RDS: 블록 저장소 기반

2. 공유 설정/로그 → 파일 저장소 (EFS)
/mnt/efs/config (여러 EC2 공유)
/mnt/efs/logs

3. 정적 파일/백업 → 객체 저장소 (S3)
이미지, 동영상, PDF
데이터베이스 백업
애플리케이션 로그 아카이브


![](https://velog.velcdn.com/images/cksgodl/post/370227ad-65aa-40e8-bf97-6f45ac290a86/image.png)

### S3의 99.999999999% (11nines) 내구성 제공 방식

> 저렴한 HDD로도 대규모 데이터를 빠르고 안정적으로 처리하는 AWS S3


1. 샤딩 (Replication)

데이터를 그대로 복사해서 여러 곳에 저장
가장 단순하지만 저장 공간 n배로 사용

2. **Erasure Coding (소거 코딩) **

- [AWS S3가 느린 HDD로 초당 1페타바이트를 제공하는 비밀](https://tilnote.io/pages/68d4cc0c9f23bb08721400b2)

데이터를 여러 조각(Fragment)으로 분할
패리티(Parity) 조각 추가로 복원 가능성 확보
RAID 5/6와 유사하지만 더 유연함

![](https://velog.velcdn.com/images/cksgodl/post/3b53c3b2-5122-4914-b217-6b5a66c1bd6c/image.png)

> S3가 사용하는 5-of-9 방식은 9개 중 5개만 있으면 원본 복원이 가능해, 데이터 안정성과 효율성 모두 잡았습니다.

![](https://velog.velcdn.com/images/cksgodl/post/1ee5c004-d075-4b01-9bc0-0d66903e8aa6/image.png)


3. 시퀀셜 I/O와 LSM 구조

HDD는 기본적으로 '순차(시퀀셜) I/O'에 강하다. 

![](https://velog.velcdn.com/images/cksgodl/post/33b5ac91-034c-42b8-9732-c705b9ec6d65/image.png)

즉, 데이터를 한꺼번에 이어 붙여 저장하거나 읽을 때 빠르기 때문에, S3의 내부 저장소(ShardStore)는 이 구조를 활용한 **LSM(로그 구조 병합 트리) 방식**을 활용한다. 



## 객체 저장소의 개념

### 버킷 (Bucket)

- 객체를 담는 최상위 컨테이너
- 전역적으로 고유한 이름 필요 (전 세계에서 유일)
- 리전(Region) 단위로 생성
- 접근 제어, 암호화, 버전 관리 등의 정책 단위


### 객체 (Object)

- 키(Key): 객체의 고유 식별자
- 데이터(Data): 실제 바이너리 데이터
- 메타데이터(Metadata): 객체에 대한 정보

### 버전 (Versioning)

- 같은 키에 여러 버전의 객체 보관
- 실수로 삭제/덮어쓰기 방지
- 각 버전은 고유 버전 ID 부여
- 삭제 마커(Delete Marker) (소프트 딜리트)


###  URI (Uniform Resource Identifier)

- 객체에 접근하는 고유 주소
- 여러 형식 존재
   - "s3://my-bucket/users/123/profile.jpg"

### SLA (Service Level Agreement)

- 서비스 제공자가 보장하는 성능/가용성 수준
- AWS S3 SLA

> 내구성 (Durability)
> 99.999999999% (11 nines)
> = 연간 10,000,000개 객체 중 1개 손실 가능성

## 아이노드(inode)의 개념

> 아이노드(inode)는 Unix/Linux 파일 시스템에서 파일이나 디렉터리의 메타데이터(속성 정보)를 담고 있는 데이터 구조로, 파일 이름, 크기, 권한, 소유자, 시간 정보, 그리고 실제 파일 데이터의 위치 등을 포함합니다.

inode는 파일 이름과는 별도로 관리되며 파일이나 디렉토리의 이름은 해당 inode에 대한 포인터로 연결된다. 
이를 통해 파일 시스템은 inode를 통해 파일의 메타데이터를 효율적으로 관리하고 동일한 파일에 대한 여러 개의 하드 링크를 지원할 수 있다.

![](https://velog.velcdn.com/images/cksgodl/post/05dac051-06b1-4494-8b88-72040a646c03/image.png)

inode가 부족한 경우 디스크에 용량이 충분하더라도 새로운 파일을 생성할 수 없다.
 
```
// ❌ 잘못된 이해
"파일명이 파일이다"

// ✅ 올바른 이해
"파일명은 inode를 가리키는 포인터일 뿐이다"

// 구조
파일명 (문자열)
   ↓ (포인터)
inode (메타데이터)
   ↓ (포인터)
데이터 블록들 (실제 내용)
```

```
# 파일의 inode 번호 확인
ls -i file.txt
# 12345678 file.txt
#    ↑ inode 번호

# 상세 정보 (ls -l + inode)
ls -li /home/user/
# 12345678 -rw-r--r-- 1 user user 1024 Oct 17 10:30 file.txt
#    ↑       ↑        ↑              ↑
# inode   권한    링크수          크기

# stat 명령으로 inode 상세 정보
stat file.txt

**출력 예시:**
  File: file.txt
  Size: 1024            Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 12345678    Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/   user)   Gid: ( 1000/   user)
Access: 2024-10-17 10:30:00.000000000 +0900
Modify: 2024-10-17 10:30:00.000000000 +0900
Change: 2024-10-17 10:30:00.000000000 +0900
Birth: 2024-10-17 10:00:00.000000000 +0900
```

## 개략적 설계안

![](https://velog.velcdn.com/images/cksgodl/post/b0e7af16-579f-4403-8598-779fed04d9ca/image.png)

### 데이터 저장소

![](https://velog.velcdn.com/images/cksgodl/post/9ba32130-7124-4ac5-9421-3a714711a402/image.png)

![](https://velog.velcdn.com/images/cksgodl/post/e78e366c-2711-4e81-908e-374255fc02da/image.png)

데이터 다중화를 위해 레플리카를 설정하고, 이를 위해서는 팩서스나 래프트 같은 합의 프로토콜을 활용하여 구축한다.

####  Raft 알고리즘

[분산 시스템의 내결함성을 높이는 뗏목 합의 알고리즘(Raft Consensus Algorithm)과 정족수(Quorum) 개념 알아보기](https://seongjin.me/raft-consensus-algorithm/)

Raft는 Paxos를 더 쉽게 이해하고 구현할 수 있도록 만든 합의 알고리즘

- 리더 선출(Leader Election): 클러스터에서 하나의 리더만 데이터 쓰기 권한을 가짐. 리더는 주기적으로 Heartbeat(신호)를 보내 자신이 리더임을 알림.
- 로그 복제(Log Replication): 모든 변경 사항을 리더가 followers에게 복제함. 모든 노드의 로그가 동일하게 유지되도록 함.
- 안정성 보장(Safety): 시스템에 장애가 발생해도, 이전에 내린 결정이 번복되지 않게 보장함.

노드의 종류

- Follower: 리더의 신호를 받는 기본 상태.
- Candidate: 리더가 사라지거나 신호를 못 받으면, 새 리더가 되기 위해 투표 요청함.
- Leader: 투표로 선출되어 log 복제 등 모든 중심 역할을 함.
![](https://velog.velcdn.com/images/cksgodl/post/b98dcbbe-4155-4d2e-82f3-cf1f3ac63a9b/image.png)

동작

1. 리더 결정
2. 데이터 변경사항을 followers에 복제
3. 모든 노드가 동의하면 변경사항이 확정됨.
![](https://velog.velcdn.com/images/cksgodl/post/4cfc3106-8cd6-4b61-b411-de5023a717b0/image.png)

Raft는 Kubernetes(쿠버네티스), etcd 등 다양한 분산 시스템에서 활용

