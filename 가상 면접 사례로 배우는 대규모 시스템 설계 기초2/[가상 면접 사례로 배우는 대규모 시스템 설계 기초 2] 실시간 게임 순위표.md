# 개략적 설계

![](https://velog.velcdn.com/images/cksgodl/post/33234557-36d7-47d3-98fe-dbdd94fdde5c/image.png)


## 유의할 점 

- 클라이언트가 순위표 서비스와 직접 통신하지 않는다.
  - 점수를 클라이언트에서 위조할 수 있음
  - 검증을 위한 서비스 단계를 둔다.
- 게임 서비스와 순위표저장소 사이에 메시지 큐가 필요한가?
  - 데이터가 다른 곳에도 이용되면 메시지큐를 지원하자.
  - 순위 알림 서비스, 분석 서비스 등..
  

# 순위표 저장소의 전택

RDB, 레디스, NoSQL 의 선택지가 있다.

## RDB

레코드가 수백만개로 증가할 때 성능이 나빠지는 이유가 있다. 

![](https://velog.velcdn.com/images/cksgodl/post/484b67bd-4b25-417b-8fc4-7473ca673888/image.png)

![](https://velog.velcdn.com/images/cksgodl/post/f6834845-0db0-47bf-bb1d-9d6ea44f53d7/image.png)

![](https://velog.velcdn.com/images/cksgodl/post/62e9cc6b-2c60-4ce2-99fe-f76a9a50bfce/image.png)

**동시 업데이트에 따라 캐시 도입도 불가능하다.**

## 레디스

![](https://velog.velcdn.com/images/cksgodl/post/d7c8b21f-db98-4b63-b985-ac335c866d27/image.png)

>Sorted Set = 자동 정렬되는 집합
- Member: 사용자 ID
- Score: 점수
- 자동으로 점수 순 정렬 유지

#### 시간 복잡도

- 추가/업데이트: O(log N)
- 순위 조회: O(log N)
- TOP N: O(log N + M)

조회 및 추가가 O(log N)인 이유는 스킵리스트를 활용함에 있다.


![](https://velog.velcdn.com/images/cksgodl/post/a1d44822-5c56-450b-876f-54ffc89530e3/image.png)

0...n 단계의 스킵리스트는 누가 결정하는가??

![](https://velog.velcdn.com/images/cksgodl/post/a5750b2f-a5d1-4ab8-9834-91c50779225b/image.png)

레디스내부에서 랜덤으로 결정

![](https://velog.velcdn.com/images/cksgodl/post/367c3bea-c5d0-4307-a486-85ac518a4eb9/image.png)

![](https://velog.velcdn.com/images/cksgodl/post/72d03a6c-f64a-4264-9fe0-8a975981f3a5/image.png)

![](https://velog.velcdn.com/images/cksgodl/post/6a7606bb-f1d1-4c2e-9a7a-9fbd4800b352/image.png)

---


![](https://velog.velcdn.com/images/cksgodl/post/b497dad1-c86c-437f-8c63-2737d838232c/image.png)

![](https://velog.velcdn.com/images/cksgodl/post/0b2210f9-c160-4e03-9827-95ce9596561f/image.png)

- 아이디를 유니크하게 만들 것
- Score정보에 timeStamp 부가정보를 추가하여 시간별 오름차순이 되게 만들 것

----

![](https://velog.velcdn.com/images/cksgodl/post/ec1f86f8-2bd4-45b8-a9b0-e9dd6468f29e/image.png)

![](https://velog.velcdn.com/images/cksgodl/post/2086eaeb-9e36-4e31-a1ef-d041a78d9d5a/image.png)

- RDB(Redis DataBase)
- AOF (Append Only File) 제공

![](https://velog.velcdn.com/images/cksgodl/post/2eb64b10-3c6d-44ff-adf5-b2eedaeea343/image.png)


#### 레디스를 활용할 때 구조


```
┌─────────────────┐
│   Client App    │
└────────┬────────┘
         │ REST/WebSocket
         ▼
┌─────────────────┐
│  API Server     │
│ (Spring Boot)   │
└────────┬────────┘
         │
    ┌────┴────┐
    ▼         ▼
┌────────┐ ┌────────────┐
│ Redis  │ │ RDB Hadoop │
│Sorted  │ │  (Backup/  │
│  Set   │ │  History)  │
└────────┘ └────────────┘
    │
    ├─ leaderboard:daily
    ├─ leaderboard:weekly
    ├─ leaderboard:monthly
    ├─ leaderboard:country:{code}
    ├─ leaderboard:level:{level}
    └─ leaderboard:event:{id}
```

- API서버와 레디스사이에 메시지큐를 두고, 메시지큐를 백업하는 형식으로 히스토리를 남길수도 있다.

### 고정파티션과 해시 파티션


![](https://velog.velcdn.com/images/cksgodl/post/ff47f4c3-5927-4303-88d5-aab8f071e7c1/image.png)

![](https://velog.velcdn.com/images/cksgodl/post/222604dc-c150-427e-bcae-092abfbcd09f/image.png)

> 레디스의 경우는 기본 key % 16384 을 해시함수로 활용한다.

또한 노드가 추가되면 기존 데이터가 재할당되는 이슈가 발생하는데 이를 해결하기 위해 원형 해시를 구현할 수 있다.

#### **기본 해시**

```
기본 해시 문제:
  hash(key) % 3 → 4로 늘리면 75% 재할당

Consistent Hashing:
  • 링 구조 사용 (0 ~ 2^32-1)
  • 노드 추가 시 일부만 재할당
  • 평균 1/N만 이동
```

#### **해시 링 동작 원리**

```
1. 해시 링 생성 (원형)

   0 ────────────────────→ 2^32
   ↑                        |
   └────────────────────────┘

2. 노드를 링에 배치

   0 ── Node1 ── Node2 ── Node3 ── 2^32

3. 키도 링에 배치

   hash("user1") = 1000 → 시계방향 가장 가까운 Node1
   hash("user2") = 5000 → Node2
   hash("user3") = 9000 → Node3

4. 노드 추가 (Node4)

   0 ── Node1 ── Node4 ── Node2 ── Node3 ── 2^32
                  ↑ 새 노드
   
   영향받는 키:
     Node1과 Node2 사이 키들만 Node4로 이동
     약 25%만 이동!
```


#### **가상 노드 (Virtual Nodes)**

또한 가상노드를 두어 핫스팟 노드를 분리할 수 있다.

```
문제: 노드가 적으면 불균등 분산

해결: 한 물리 노드를 여러 가상 노드로

예시:
  Node1 → VNode1-1, VNode1-2, ..., VNode1-100
  Node2 → VNode2-1, VNode2-2, ..., VNode2-100
  Node3 → VNode3-1, VNode3-2, ..., VNode3-100
```

## NoSQL

카산드라 또는 MongoDB, DynamoDB를 활용할 수 있다.

이는 기존 키(primary Key)와 별개로 전역 보조 색인(global secondary index)를 활용할 수 있다. 

### GSI (Glogbal Secondary Index)

Primary Key 외에 다른 컬럼으로도 빠르게 조회할 수 있게 해주는 추가 인덱스

![](https://velog.velcdn.com/images/cksgodl/post/6e635b8f-237b-4e1a-aa2c-4bbf64c952f9/image.png)

![](https://velog.velcdn.com/images/cksgodl/post/cbf0d6a0-85a6-4158-9c3e-627a134078da/image.png)

![](https://velog.velcdn.com/images/cksgodl/post/531018c7-3f53-4fd2-99f1-ee66804cd23c/image.png)

![](https://velog.velcdn.com/images/cksgodl/post/3adc2d7b-891f-4d21-9427-bb16d289c44e/image.png)

**GSI 동작:**

1. 별도 테이블처럼 저장 (물리적 분리)
2. 완전히 독립적인 조회 패턴
3. 처리량 독립

#### **핵심 차이점**

| 특성 | LSI | GSI |
|------|-----|-----|
| **Partition Key** | Primary와 동일 (필수) | 완전히 다를 수 있음 |
| **Sort Key** | 다르게 설정 | 다르게 설정 (선택) |
| **범위** | 같은 파티션 내 (Local) | 전체 테이블 (Global) |
| **생성 시점** | 테이블 생성 시만 | 언제든지 추가/삭제 |
| **개수 제한** | 최대 5개 | 최대 20개 |
| **읽기 일관성** | Strong/Eventually | Eventually만 |
| **처리량** | Primary와 공유 | 독립적 (별도 설정) |
| **크기 제한** | 10GB/파티션 | 무제한 |
| **비용** | Primary 읽기/쓰기 포함 | 별도 읽기/쓰기 비용 |


#### GSI 사용 시 주의사항

- 추가 읽기/쓰기 비용 발생

```
GSI는 별도 테이블처럼 작동
→ 추가 저장 공간 필요
→ 추가 읽기/쓰기 비용 발생

예시:
  Primary Table: 100GB
  GSI 1개: 100GB 추가
  GSI 2개: 200GB 추가
  
  총 저장 공간: 300GB
  비용: 3배!
```

- ** Eventually Consistent (최종 일관성)**

Primary 테이블 업데이트 → GSI 반영까지 시간 지연 (보통 1초 이내) 발생





