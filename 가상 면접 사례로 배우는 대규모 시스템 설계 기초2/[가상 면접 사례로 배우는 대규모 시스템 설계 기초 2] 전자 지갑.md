전자 지갑 서비스에서 가장 중요한 것은 정확성일 것이다.

따라서 데이터베이스를 선택할 때 레디스 클러스터는 활용하지 못한다.


## 레디스 클러스터의 정확성 보장


> Q. 레디스 클러스터를 활용해 샤딩하면 정확성 요구사항을 충족하지 못해?
예를들면 두 개의 레디스 노드를 업데이트하는데, 두 연산이 모두 성공하라는 보장은 없나?

A. 그렇다

![](https://velog.velcdn.com/images/cksgodl/post/923a4d8c-e5bb-48c7-affc-e890898adc0d/image.png)

Redis 클러스터는 키를 해시 슬롯(16384개)에 따라 분산시키는데, 서로 다른 슬롯에 있는 키들은 다른 노드에 저장될 수 있다. 이 경우 단일 트랜잭션으로 묶을 수 없다.

- 예를 들어 user:1001:balance와 user:2002:balance 두 키가 각각 다른 노드에 있으면, 둘 다 업데이트하는 중 하나만 성공하고 하나가 실패하는 상황이 발생할 수 있음

그래도 해결 방법은 존재한다.

- 첫 번째로 해시 함수를 활용. {user}:1001:balance처럼 중괄호 안의 부분만으로 해시를 계산하게 해서 같은 노드에 모으는 방식
- 두 번째로 Lua 스크립트 활용. 하지만 역시 같은 노드 내 키들에만 적용.
- 세 번째로 애플리케이션 레벨 보상 트랜잭션을 구현
- **네 번째로 Redis 외부 솔루션을 고려. 정확성이 정말 중요하다면 관계형 DB의 트랜잭션을 쓰거나, 분산 트랜잭션 코디네이터(2PC 등)를 도입하는 방법.
**

정확성을 제공하기에 레디스 클러스터는 충분하지 않다.

## 분산 트랜잭션

필자는 트랜잭션을 지원하는 관계형 데이터베이스를 활용하라고 한다. 그렇다면 샤딩된 RDB 노드에서의 트랜잭션은 어떻게 지원하는가??

### 2PC Commit

![](https://velog.velcdn.com/images/cksgodl/post/f27ba394-2793-4975-94b9-bef60de984eb/image.png)

- Phase 1: Prepare (투표 단계)
- Phase 2: Commit/Abort (결정 단계)

문제점

- 블로킹 문제 (락)
- 성능 오버헤드가 큼. (네트워크 왕복이 최소 2번 필요.) 
- 단일 장애점 (코디네이터가 SPOF가 될 수 있음)

### TC/C (Try-Confirm/Cancel)

> 2PC는 리소스 레벨에서 락을 잡고 기다리는 반면, TC/C는 비즈니스 로직 레벨에서 "예약" 개념을 도입한다. 리소스를 직접 잠그지 않고, 임시로 예약한다.

- `NOP` 응답을 받는것이 리소스를 예약하는 것

따라서 각각의 단계가 별도 트랜잭션이다.

아래의 예시를 참고

![](https://velog.velcdn.com/images/cksgodl/post/93aaeaea-6a43-4b03-a8bb-3edfbe5ea780/image.png)

![](https://velog.velcdn.com/images/cksgodl/post/1fca2d0e-9df9-4bd2-82a0-5da7085e77a2/image.png)

![](https://velog.velcdn.com/images/cksgodl/post/c12b22de-498c-4ab6-9d86-9f06f0d24a64/image.png)


### 2PC와 TC/C 차이

2PC는 DB 락을 잡은 채로 대기하지만, TC/C는 락 없이 비즈니스 상태로 관리한다. 그래서 코디네이터가 죽어도 다른 트랜잭션들이 블로킹되지 않아, 예약 상태인 리소스만 일시적으로 사용 불가하고, 나머지는 정상 작동하고 성능면에도 이득이다.

### 단계별 상태 테이블

![](https://velog.velcdn.com/images/cksgodl/post/16d64732-ef23-4990-9e0d-138c76fd052c/image.png)

각 상태를 지갑 계정이 있는 노드에 두어 작업 로그를 쌓을 수 있다.

해당 로그를 통해 불균형 상태나, 잘못된 순서로 실행된 경우를 복구할 수 있다.

## 분산 트랜잭션 : SAGA

> Saga 패턴은 분산 트랜잭션을 여러 개의 로컬 트랜잭션으로 분해하고, 실패 시 보상 트랜잭션(Compensating Transaction)으로 되돌리는 방식

![](https://velog.velcdn.com/images/cksgodl/post/ef2f44ba-3d6f-4437-ab2b-12d7c5bb5fe2/image.png)

단점
- 격리성(Isolation) 문제. 중간 상태가 다른 트랜잭션에게 보인다. 
  - 예를 들어 포인트를 차감했는데 나중에 보상으로 환불되면, 중간에 "차감된 상태"를 다른 사용자가 볼 수 있음
- 보상 트랜잭션이 복잡할 수 있다. 
  - 모든 액션에 대해 완벽한 보상 로직을 작성해야 함
- `Choreography` 방식은 디버깅이 어렵다. 
  - 이벤트가 여기저기 날아다녀서 전체 흐름을 추적하기 힘들다.
  

## 이벤트 소싱

> 예를 들어 사용자가 애플리케이션 수준에서 잘못된 작업을 입력할 수도 있다. (입력된 금액 자체가 잘못됨) 그러니 문제의 근본 원인을 역추적하고 모든 계정에서 발생하는 연산을 감사할 방법이 있다면 좋을 텐데, 어떻게 하면 좋을까?

- 특정 시점의 계정 잔액을 알 수 있나요?
- 과거 및 현재 계정 잔액이 정확한지 어떻게 알 수 있나요?
- 코드 변경 후에도 시스템 로직이 올바른지 어떻게 검증하나요?

이럴 때를 위해 이벤트 소싱을 활용한다.

![](https://velog.velcdn.com/images/cksgodl/post/a112959e-0e96-483e-b55c-8a65dafff993/image.png)

### 이벤트 소싱과 EDD의 차이점

- Event Sourcing : 이벤트를 상태 저장의 근본으로 사용하는 패턴. 현재 상태를 직접 저장하지 않고, 상태를 변경시킨 모든 이벤트들을 저장.
- Event-Driven Architecture (EDA) : 이벤트를 통신 수단으로 사용하는 아키텍쳐. 서비스 간 느슨한 결합을 위해 이벤트를 주고받음.

핵심 차이점
- 저장 방식:
  - EDA: 현재 상태를 DB에 저장 + 이벤트는 통신용으로만 사용
  - Event Sourcing: 이벤트만 저장, 상태는 이벤트로부터 재구성
- 이벤트의 역할:
  - EDA: 서비스 간 통신 메커니즘 (메시지)
  - Event Sourcing: 상태 변경의 기록 (Source of Truth)
- 상태 조회:
  - EDA: SELECT * FROM orders WHERE id = ? (빠름)
  - Event Sourcing: 모든 이벤트 로드 → 순차 적용 (느림, CQRS로 개선)
    - 이벤트 소싱을 활용할 시에 현재 상태를 알기위해서는 순차적으로 이벤트를 재생(replay)해야 한다.



### CQRS (Command Query Responsibility Segregation)

Event Sourcing의 단점으로 조회 성능이 안 좋다. 현재 상태를 알려면 매번 모든 이벤트를 재생해야 한다. 그래서 `CQRS(Command Query Responsibility Segregation)`와 함께 사용

![](https://velog.velcdn.com/images/cksgodl/post/945a35eb-10e6-4af5-a72d-45d8b1bd619f/image.png)

1. 모든 이벤트를 외부에 보낸다. 
2. 이벤트를 수신하는 외부 주체가 직접 상태를 재구축
   - 이런 설계 철학을 명령-질의 책임 분리 (CQRS)라고 한다.
3. CQRS 에서는 상태 기록을 담당하는 상태기계는 하나고, 읽기 전용 상태기계는 여러개 있을 수 있다. 
4. 읽기 전용 상태 기계는 상태 뷰(view)를 만들고, 이 뷰는 질의(query)에 이용된다.


### [이벤트 소싱 패턴 (microsoft Learn)](https://learn.microsoft.com/ko-kr/azure/architecture/patterns/event-sourcing)

![](https://velog.velcdn.com/images/cksgodl/post/48b35fa9-c531-49da-b9b2-8190feb40b2c/image.png)

![](https://velog.velcdn.com/images/cksgodl/post/6d5af956-18f1-40a1-a358-db56de1a23f3/image.png)

### [이벤트 소싱 패턴 (aws)](https://docs.aws.amazon.com/ko_kr/prescriptive-guidance/latest/cloud-design-patterns/event-sourcing.html)

![](https://velog.velcdn.com/images/cksgodl/post/e080c438-eb18-431c-8389-b95cc7b18e12/image.png)

![](https://velog.velcdn.com/images/cksgodl/post/e874beb1-9bb8-47ab-ae0e-63e6cf07ce71/image.png)

![](https://velog.velcdn.com/images/cksgodl/post/c3d662a2-86c3-4379-b707-4ffbee354773/image.png)



